import {
  DEFAULT_ASCENT,
  DEFAULT_DESCENT,
  DEFAULT_UNITS_PER_EM,
  normalizeSvgPaths,
} from "../../core/svg-font-generator";
import { GlyphMeta } from "../../types";
import {
  isWhiteFill,
  orientContoursEvenOdd,
  pathToContours,
  TtfContour,
  TtfPoint,
} from "./svg-to-ttf-path";

/**
 * Font and Glyph builder classes
 * Manages font metadata and glyph data structures
 */

const VERSION_RE = /^(Version )?(\d+[.]\d+)$/i;
const toInt = (value: number): number => Math.trunc(value);

type SfntName = { id: number; value: string };

export class Contour {
  points: TtfPoint[] = [];
}

export class Glyph {
  contours: Contour[] = [];
  d = "";
  id = 0;
  codes: number[] = [];
  height = 0;
  name = "";
  width = 0;
  unicode = 0;
  ttfContours: TtfContour[] = [];
  ttf_flags: number[] = [];
  ttf_x: number[] = [];
  ttf_y: number[] = [];
  ttf_size = 0;

  get xMin(): number {
    let xMin = 0;
    let hasPoints = false;
    this.contours.forEach((contour) => {
      contour.points.forEach((point) => {
        xMin = Math.min(xMin, Math.floor(point.x));
        hasPoints = true;
      });
    });
    if (xMin < -32768) {
      throw new Error(
        `xMin value for glyph ${this.name ? `"${this.name}"` : JSON.stringify(this.codes)} is out of bounds (actual ${xMin}, expected -32768..32767, d="${this.d}")`,
      );
    }
    return hasPoints ? xMin : 0;
  }

  get xMax(): number {
    let xMax = 0;
    let hasPoints = false;
    this.contours.forEach((contour) => {
      contour.points.forEach((point) => {
        xMax = Math.max(xMax, -Math.floor(-point.x));
        hasPoints = true;
      });
    });
    if (xMax > 32767) {
      throw new Error(
        `xMax value for glyph ${this.name ? `"${this.name}"` : JSON.stringify(this.codes)} is out of bounds (actual ${xMax}, expected -32768..32767, d="${this.d}")`,
      );
    }
    return hasPoints ? xMax : this.width;
  }

  get yMin(): number {
    let yMin = 0;
    let hasPoints = false;
    this.contours.forEach((contour) => {
      contour.points.forEach((point) => {
        yMin = Math.min(yMin, Math.floor(point.y));
        hasPoints = true;
      });
    });
    if (yMin < -32768) {
      throw new Error(
        `yMin value for glyph ${this.name ? `"${this.name}"` : JSON.stringify(this.codes)} is out of bounds (actual ${yMin}, expected -32768..32767, d="${this.d}")`,
      );
    }
    return hasPoints ? yMin : 0;
  }

  get yMax(): number {
    let yMax = 0;
    let hasPoints = false;
    this.contours.forEach((contour) => {
      contour.points.forEach((point) => {
        yMax = Math.max(yMax, -Math.floor(-point.y));
        hasPoints = true;
      });
    });
    if (yMax > 32767) {
      throw new Error(
        `yMax value for glyph ${this.name ? `"${this.name}"` : JSON.stringify(this.codes)} is out of bounds (actual ${yMax}, expected -32768..32767, d="${this.d}")`,
      );
    }
    return hasPoints ? yMax : 0;
  }
}

export class Font {
  ascent = DEFAULT_ASCENT;
  copyright = "";
  createdDate = new Date();
  glyphs: Glyph[] = [];
  ligatures: { ligature: string; unicode: number[]; glyph: Glyph }[] = [];
  codePoints: Record<number, Glyph> = {};
  isFixedPitch = 0;
  italicAngle = 0;
  familyClass = 0;
  familyName = "";
  fsSelection = 0x40 | 0x80;
  fsType = 0;
  lowestRecPPEM = 8;
  macStyle = 0;
  modifiedDate = new Date();
  panose = {
    familyType: 2,
    serifStyle: 0,
    weight: 5,
    proportion: 3,
    contrast: 0,
    strokeVariation: 0,
    armStyle: 0,
    letterform: 0,
    midline: 0,
    xHeight: 0,
  };
  revision = 1;
  sfntNames: SfntName[] = [];
  underlineThickness = 0;
  unitsPerEm = DEFAULT_UNITS_PER_EM;
  weightClass = 400;
  width = DEFAULT_UNITS_PER_EM;
  height = DEFAULT_UNITS_PER_EM;
  widthClass = 5;
  ySubscriptXOffset = 0;
  ySuperscriptXOffset = 0;
  int_descent = DEFAULT_DESCENT;
  xHeight = 0;
  capHeight = 0;
  int_ySubscriptXSize?: number;
  int_ySubscriptYSize?: number;
  int_ySubscriptYOffset?: number;
  int_ySuperscriptXSize?: number;
  int_ySuperscriptYSize?: number;
  int_ySuperscriptYOffset?: number;
  int_yStrikeoutSize?: number;
  int_yStrikeoutPosition?: number;
  int_lineGap?: number;
  int_underlinePosition?: number;
  ttf_glyph_size = 0;
  description = "Generated by svg2font-cli.";
  url = "https://github.com/jayson991/svg2font-cli";
  id = "";

  get descent(): number {
    return this.int_descent;
  }

  set descent(value: number) {
    this.int_descent = Math.round(-Math.abs(value));
  }

  get avgCharWidth(): number {
    if (!this.glyphs.length) return 0;
    const widths = this.glyphs.map((g) => g.width);
    return toInt(widths.reduce((sum, val) => sum + val, 0) / widths.length);
  }

  get ySubscriptXSize(): number {
    return toInt(this.int_ySubscriptXSize ?? this.width * 0.6347);
  }

  set ySubscriptXSize(value: number) {
    this.int_ySubscriptXSize = value;
  }

  get ySubscriptYSize(): number {
    return toInt(this.int_ySubscriptYSize ?? (this.ascent - this.descent) * 0.7);
  }

  set ySubscriptYSize(value: number) {
    this.int_ySubscriptYSize = value;
  }

  get ySubscriptYOffset(): number {
    return toInt(this.int_ySubscriptYOffset ?? (this.ascent - this.descent) * 0.14);
  }

  set ySubscriptYOffset(value: number) {
    this.int_ySubscriptYOffset = value;
  }

  get ySuperscriptXSize(): number {
    return toInt(this.int_ySuperscriptXSize ?? this.width * 0.6347);
  }

  set ySuperscriptXSize(value: number) {
    this.int_ySuperscriptXSize = value;
  }

  get ySuperscriptYSize(): number {
    return toInt(this.int_ySuperscriptYSize ?? (this.ascent - this.descent) * 0.7);
  }

  set ySuperscriptYSize(value: number) {
    this.int_ySuperscriptYSize = value;
  }

  get ySuperscriptYOffset(): number {
    return toInt(this.int_ySuperscriptYOffset ?? (this.ascent - this.descent) * 0.48);
  }

  set ySuperscriptYOffset(value: number) {
    this.int_ySuperscriptYOffset = value;
  }

  get yStrikeoutSize(): number {
    return toInt(this.int_yStrikeoutSize ?? (this.ascent - this.descent) * 0.049);
  }

  set yStrikeoutSize(value: number) {
    this.int_yStrikeoutSize = value;
  }

  get yStrikeoutPosition(): number {
    return toInt(this.int_yStrikeoutPosition ?? (this.ascent - this.descent) * 0.258);
  }

  set yStrikeoutPosition(value: number) {
    this.int_yStrikeoutPosition = value;
  }

  get minLsb(): number {
    return toInt(Math.min(...this.glyphs.map((g) => g.xMin)));
  }

  get minRsb(): number {
    if (!this.glyphs.length) return toInt(this.width);
    return toInt(
      this.glyphs.reduce(
        (minRsb, glyph) => Math.min(minRsb, glyph.width - glyph.xMax),
        Number.POSITIVE_INFINITY,
      ),
    );
  }

  get xMin(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((xMin, glyph) => Math.min(xMin, glyph.xMin), 0);
  }

  get yMin(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((yMin, glyph) => Math.min(yMin, glyph.yMin), 0);
  }

  get xMax(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((xMax, glyph) => Math.max(xMax, glyph.xMax), 0);
  }

  get yMax(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((yMax, glyph) => Math.max(yMax, glyph.yMax), 0);
  }

  get avgWidth(): number {
    const len = this.glyphs.length;
    if (!len) return this.width;
    const sumWidth = this.glyphs.reduce((sum, glyph) => sum + glyph.width, 0);
    return Math.round(sumWidth / len);
  }

  get maxWidth(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((maxWidth, glyph) => Math.max(maxWidth, glyph.width), 0);
  }

  get maxExtent(): number {
    if (!this.glyphs.length) return this.width;
    return this.glyphs.reduce((maxExtent, glyph) => Math.max(maxExtent, glyph.xMax), 0);
  }

  get lineGap(): number {
    return toInt(this.int_lineGap ?? (this.ascent - this.descent) * 0.09);
  }

  set lineGap(value: number) {
    this.int_lineGap = value;
  }

  get underlinePosition(): number {
    return toInt(this.int_underlinePosition ?? (this.ascent - this.descent) * 0.01);
  }

  set underlinePosition(value: number) {
    this.int_underlinePosition = value;
  }
}

const sanitizePostscriptName = (value: string): string =>
  value.replace(/[\s()[\]<>%/]/g, "").slice(0, 62);

export const buildFontFromGlyphs = (
  glyphs: GlyphMeta[],
  fontName: string,
  unitsPerEm: number = DEFAULT_UNITS_PER_EM,
  versionString = "Version 1.0",
): Font => {
  const font = new Font();
  font.id = fontName;
  font.familyName = fontName;
  font.unitsPerEm = unitsPerEm;
  font.width = unitsPerEm;
  font.height = unitsPerEm;
  font.descent = DEFAULT_DESCENT;
  font.ascent = DEFAULT_ASCENT;

  if (typeof versionString !== "string" || !VERSION_RE.test(versionString)) {
    throw new Error(`svg2font: invalid version string "${versionString}"`);
  }

  const normalizedVersion = `Version ${versionString.match(VERSION_RE)![2]}`;
  font.sfntNames.push({ id: 2, value: "Regular" });
  font.sfntNames.push({ id: 4, value: fontName });
  font.sfntNames.push({ id: 5, value: normalizedVersion });
  font.sfntNames.push({ id: 6, value: sanitizePostscriptName(fontName) });

  const missingGlyph = new Glyph();
  missingGlyph.name = ".notdef";
  missingGlyph.width = unitsPerEm;
  missingGlyph.height = unitsPerEm;
  font.glyphs.push(missingGlyph);

  glyphs.forEach((glyphMeta) => {
    const glyph = new Glyph();
    glyph.name = glyphMeta.name;
    glyph.codes = [glyphMeta.codepoint];
    glyph.unicode = glyphMeta.codepoint;
    glyph.width = unitsPerEm;
    glyph.height = unitsPerEm;
    const normalized = normalizeSvgPaths(glyphMeta.svg, unitsPerEm);
    glyph.d = normalized.d;

    const contoursWithMeta: Array<{ contour: TtfContour; forceHole: boolean }> = [];
    normalized.paths.forEach((path) => {
      const pathContours = pathToContours(path.d, unitsPerEm);
      const forceHole = isWhiteFill(path.fill);
      pathContours.forEach((ctr) => contoursWithMeta.push({ contour: ctr, forceHole }));
    });

    const orientedContours = orientContoursEvenOdd(contoursWithMeta);
    glyph.contours = orientedContours.map((ctr) => {
      const contour = new Contour();
      contour.points = ctr.map((pt) => ({ x: pt.x, y: pt.y, onCurve: pt.onCurve }));
      return contour;
    });
    font.glyphs.push(glyph);
    if (!font.codePoints[glyphMeta.codepoint]) {
      font.codePoints[glyphMeta.codepoint] = glyph;
    }
  });

  font.glyphs.forEach((glyph, index) => {
    glyph.id = index;
  });

  return font;
};
